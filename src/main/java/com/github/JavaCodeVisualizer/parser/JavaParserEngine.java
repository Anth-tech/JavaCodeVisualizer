package com.github.JavaCodeVisualizer.parser;

import com.github.JavaCodeVisualizer.model.*;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.PackageDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.visitor.VoidVisitor;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * Engine for parsing file(s) and storing their metadata into subcomponents
 * that model each part of a Java file
 */
public class JavaParserEngine {

    /**
     * Parses a directory into compilation units with their file paths
     * @param files array of java files from a chosen directory
     * @return hashmap with the path and corresponding compilation unit
     * @throws IOException if path is missing or invalid
     */
    public static Map<Path, CompilationUnit> parseDirectory(File[] files) throws IOException {
        Map<Path, CompilationUnit> compilationUnits = new HashMap<>();
        for (File file: files) {
            String filePath = file.getAbsolutePath();
            Path path = Paths.get(filePath);
            CompilationUnit root = StaticJavaParser.parse(Files.newInputStream(path));
            compilationUnits.put(path, root);
        }
        return compilationUnits;
    }

    /**
     * Parses a single file into a compilation unit with its file path
     * @param file java file to be parsed
     * @return hashmap with the path and corresponding compilation unit
     * @throws IOException if the path is missing or invalid
     */
    public static Map<Path, CompilationUnit> parseSingleFile(File file) throws IOException {
        Map<Path, CompilationUnit> compilationUnits = new HashMap<>();
        String filePath = file.getAbsolutePath();
        Path path = Paths.get(filePath);
        CompilationUnit root = StaticJavaParser.parse(Files.newInputStream(path));
        compilationUnits.put(path, root);
        return compilationUnits;
    }

    /**
     * Parses the compilation units generated by parseDirectory and stores them as JavaFileObjects
     * @param compilationUnits the compilation units of the files parsed by JavaParser
     * @return A list of JavaFileObjects
     */
    public static List<JavaFileObject> parse(Map<Path, CompilationUnit> compilationUnits) {
        List<JavaFileObject> parsedFiles = new ArrayList<>();
        for (Map.Entry<Path, CompilationUnit> entry : compilationUnits.entrySet()) {
            parsedFiles.add(getJavaFileObject(entry.getValue(), entry.getKey()));
        }
        return parsedFiles;
    }

    /**
     * Turns a compilation unit into a JavaFileObject
     * @param root the compilation unit of the file
     * @param path the path of the file
     * @return A JavaFileObject representing the file
     */
    private static JavaFileObject getJavaFileObject(CompilationUnit root, Path path) {
        Map<String, List<ClassOrInterfaceDeclaration>> classesAndInterfaces = extractClassesAndInterfaces(root);
        List<JavaClassObject> classesList = getJavaClassObjects(classesAndInterfaces);
        List<JavaClassObject> interfacesList = getJavaInterfaceObjects(classesAndInterfaces);
        Optional<PackageDeclaration> optionalPkg = root.getPackageDeclaration();
        String packageName = optionalPkg
                .map(PackageDeclaration::getNameAsString)
                .orElse("no package");
        return new JavaFileObject.Builder()
                .fileName(path.getFileName().toString())
                .filePath(path)
                .classes(classesList)
                .interfaces(interfacesList)
                .filePackage(packageName)
                .imports(root.getImports())
                .build();
    }

    /**
     * Extracts and separates the classes and interfaces from a compilation unit
     * @param root the compilation unit to extract from
     * @return A map storing a classes list and an interfaces list
     */
    private static Map<String, List<ClassOrInterfaceDeclaration>> extractClassesAndInterfaces(CompilationUnit root) {
        Map<String, List<ClassOrInterfaceDeclaration>> classesAndInterfaces = new HashMap<>();
        classesAndInterfaces.put("Classes", new ArrayList<>());
        classesAndInterfaces.put("Interfaces", new ArrayList<>());
        VoidVisitor<Map<String, List<ClassOrInterfaceDeclaration>>> classInterfaceCollector = new ClassCollector();
        classInterfaceCollector.visit(root, classesAndInterfaces);
        return classesAndInterfaces;
    }

    /**
     * Turns ClassOrInterfaceDeclarations into JavaClassObjects representing classes
     * @param classesAndInterfaces A map containing a list for classes and a list for interfaces
     * @return A list of JavaClassObjects
     */
    private static List<JavaClassObject> getJavaClassObjects(Map<String, List<ClassOrInterfaceDeclaration>> classesAndInterfaces) {
        List<JavaClassObject> classesList = new ArrayList<>();
        classesAndInterfaces.get("Classes").forEach(c ->  {
            List<JavaMethodObject> methods = getJavaMethodObjects(c);
            List<JavaFieldObject> fields = getJavaFieldObjects(c);

            classesList.add(new JavaClassObject.Builder()
                    .className(c.getNameAsString())
                    .modifiers(c.getModifiers())
                    .extendedTypes(c.getExtendedTypes())
                    .interfaceNames(c.getImplementedTypes())
                    .methods(methods)
                    .fields(fields)
                    .build()
            );
        });
        return classesList;
    }

    /**
     * Turns ClassOrInterfaceDeclarations into JavaClassObjects representing interfaces
     * @param classesAndInterfaces A map containing a list for classes and a list for interfaces
     * @return A list of JavaClassObjects
     */
    private static List<JavaClassObject> getJavaInterfaceObjects(Map<String, List<ClassOrInterfaceDeclaration>> classesAndInterfaces) {
        List<JavaClassObject> interfacesList = new ArrayList<>();
        classesAndInterfaces.get("Interfaces").forEach(c ->  {
            List<JavaMethodObject> methods = getJavaMethodObjects(c);
            List<JavaFieldObject> fields = getJavaFieldObjects(c);

            interfacesList.add(new JavaClassObject.Builder()
                    .className(c.getNameAsString())
                    .modifiers(c.getModifiers())
                    .extendedTypes(c.getExtendedTypes())
                    .interfaceNames(c.getImplementedTypes())
                    .methods(methods)
                    .fields(fields)
                    .build()
            );
        });
        return interfacesList;
    }

    /**
     * Extracts methods from a class or interface and stores them as JavaMethodObjects
     * @param c ClassOrInterfaceDeclaration to extract from
     * @return A list of JavaMethodObjects
     */
    private static List<JavaMethodObject> getJavaMethodObjects(ClassOrInterfaceDeclaration c) {
        List<MethodDeclaration> methodDeclarations = c.getMethods();
        List<JavaMethodObject> methods = new ArrayList<>();
        methodDeclarations.forEach(md -> {
            Optional<BlockStmt> optionalBlk = md.getBody();
            String body = optionalBlk
                    .map(BlockStmt::toString)
                    .orElse("no body");
            methods.add(new JavaMethodObject.Builder()
                    .methodName(md.getNameAsString())
                    .returnType(md.getTypeAsString())
                    .modifiers(md.getModifiers())
                    .parameters(md.getParameters())
                    .exceptionTypes(md.getThrownExceptions())
                    .methodBody(body)
                    .build()
            );
        });
        return methods;
    }

    /**
     * Extracts fields from a class or interface and stores them as JavaFieldObjects
     * @param c ClassOrInterfaceDeclaration to extract from
     * @return A list of JavaFieldObjects
     */
    private static List<JavaFieldObject> getJavaFieldObjects(ClassOrInterfaceDeclaration c) {
        List<FieldDeclaration> fieldDeclarations = c.getFields();
        List<JavaFieldObject> fields = new ArrayList<>();
        fieldDeclarations.forEach(f -> {
            List<JavaVariableObject> variables = getJavaVariableObjects(f);
            fields.add(new JavaFieldObject.Builder()
                    .fieldBody(f.toString())
                    .variables(variables)
                    .modifiers(f.getModifiers())
                    .build()
            );
        });
        return fields;
    }

    /**
     * Extracts variables from a field and stores them as JavaVariableObjects
     * @param f FieldDeclaration to extact from
     * @return A List of JavaVariableObjects
     */
    private static List<JavaVariableObject> getJavaVariableObjects(FieldDeclaration f) {
        List<VariableDeclarator> variableDeclarators = f.getVariables();
        List<JavaVariableObject> variables = new ArrayList<>();
        variableDeclarators.forEach(v -> {
            variables.add(new JavaVariableObject.Builder()
                    .name(v.getNameAsString())
                    .type(v.getType().asString())
                    .initializer(v.getInitializer().toString())
                    .build()
            );
        });
        return variables;
    }
}
